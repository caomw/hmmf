!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
Box	rrt.h	/^typedef struct Box{$/;"	s
Box	rrt.h	/^}Box;$/;"	t	typeref:struct:Box
EXTEND_DIST	rrt.cpp	6;"	d	file:
GOAL_PROB	rrt.cpp	8;"	d	file:
Goal	rrt.h	/^typedef struct Goal{$/;"	s
Goal	rrt.h	/^}Goal;$/;"	t	typeref:struct:Goal
INF	rrt.cpp	5;"	d	file:
MAX	genobs.c	6;"	d	file:
MAX_OBS_SIZE	rrt.cpp	/^double MAX_OBS_SIZE = 0;$/;"	v
MIN	genobs.c	5;"	d	file:
NUM_OBSTACLES	rrt.cpp	/^double NUM_OBSTACLES = 0;$/;"	v
NUM_STATES	rrt.h	13;"	d
Node	rrt.h	/^        Node()$/;"	f	class:Node
Node	rrt.h	/^        Node(State s, Node *p, double c1=0, double c2=0, double c3=0)$/;"	f	class:Node
Node	rrt.h	/^class Node$/;"	c
RRT_BOWL_SIZE	rrt.cpp	7;"	d	file:
SQ	kdtree.c	83;"	d	file:
State	rrt.h	/^        State()$/;"	f	class:State
State	rrt.h	/^        State(double *s)$/;"	f	class:State
State	rrt.h	/^class State$/;"	c
USE_KDTREE	rrt.cpp	9;"	d	file:
_KDTREE_H_	kdtree.h	28;"	d
__RANDOM_H__	random.h	2;"	d
__RRT_H__	rrt.h	2;"	d
alloc_mutex	kdtree.c	/^static pthread_mutex_t alloc_mutex = PTHREAD_MUTEX_INITIALIZER;$/;"	v	file:
alloc_resnode	kdtree.c	/^static struct res_node *alloc_resnode(void)$/;"	f	file:
alloc_resnode	kdtree.c	101;"	d	file:
box	rrt.cpp	/^Box box;$/;"	v
branch_and_bound	main.cpp	/^void branch_and_bound(int num, int output_path)$/;"	f
can_join_nodes	rrt.cpp	/^bool can_join_nodes(Node n1, Node n2)$/;"	f
center	rrt.h	/^    State center;$/;"	m	struct:Box
cgoal	rrt.h	/^        double cgoal;       \/\/ heuristic$/;"	m	class:Node
clear_rec	kdtree.c	/^static void clear_rec(struct kdnode *node, void (*destr)(void*))$/;"	f	file:
clear_results	kdtree.c	/^static void clear_results(struct kdres *rset)$/;"	f	file:
cparent	rrt.h	/^        double cparent;     \/\/ cost from parent$/;"	m	class:Node
csrc	rrt.h	/^        double csrc;        \/\/ cost from src$/;"	m	class:Node
data	kdtree.c	/^    void *data;$/;"	m	struct:kdnode	file:
destr	kdtree.c	/^    void (*destr)(void*);$/;"	m	struct:kdtree	file:
dim	kdtree.c	/^    int dim;$/;"	m	struct:kdhyperrect	file:
dim	kdtree.c	/^    int dim;$/;"	m	struct:kdtree	file:
dir	kdtree.c	/^    int dir;$/;"	m	struct:kdnode	file:
dist	rrt.cpp	/^double dist(State s1, State s2) $/;"	f
dist_sq	kdtree.c	/^    double dist_sq;$/;"	m	struct:res_node	file:
does_line_hit	rrt.cpp	/^bool does_line_hit(State s1, State s2, double *pos, double rad)$/;"	f
extend_rrt	rrt.cpp	/^Node extend_rrt(Node *near, State s)$/;"	f
extend_rrtstar	rrt.cpp	/^int extend_rrtstar(kdtree *node_tree, Node *near, State s, Node &returned_node, double curr_min_cost)$/;"	f
find_nearest	kdtree.c	/^static int find_nearest(struct kdnode *node, const double *pos, double range, struct res_node *list, int ordered, int dim)$/;"	f	file:
free_nodes	kdtree.c	/^static struct res_node *free_nodes;$/;"	v	typeref:struct:res_node	file:
free_resnode	kdtree.c	/^static void free_resnode(struct res_node *node)$/;"	f	file:
free_resnode	kdtree.c	102;"	d	file:
get_msec	random.cpp	/^double get_msec()$/;"	f
goal	rrt.cpp	/^Goal goal;$/;"	v
hyperrect_create	kdtree.c	/^static struct kdhyperrect* hyperrect_create(int dim, const double *min, const double *max)$/;"	f	file:
hyperrect_dist_sq	kdtree.c	/^static double hyperrect_dist_sq(struct kdhyperrect *rect, const double *pos)$/;"	f	file:
hyperrect_duplicate	kdtree.c	/^static struct kdhyperrect* hyperrect_duplicate(const struct kdhyperrect *rect)$/;"	f	file:
hyperrect_extend	kdtree.c	/^static void hyperrect_extend(struct kdhyperrect *rect, const double *pos)$/;"	f	file:
hyperrect_free	kdtree.c	/^static void hyperrect_free(struct kdhyperrect *rect)$/;"	f	file:
init_rand	random.cpp	/^void init_rand()$/;"	f
insert_rec	kdtree.c	/^static int insert_rec(struct kdnode **nptr, const double *pos, void *data, int dir, int dim)$/;"	f	file:
is_inside_goal	rrt.cpp	/^bool is_inside_goal(State c)$/;"	f
is_obstructed	rrt.cpp	/^bool is_obstructed(State s)$/;"	f
is_valid	genobs.c	/^int is_valid(double x, double y, double r)$/;"	f
item	kdtree.c	/^    struct kdnode *item;$/;"	m	struct:res_node	typeref:struct:res_node::kdnode	file:
kd_clear	kdtree.c	/^void kd_clear(struct kdtree *tree)$/;"	f
kd_create	kdtree.c	/^struct kdtree *kd_create(int k)$/;"	f
kd_data_destructor	kdtree.c	/^void kd_data_destructor(struct kdtree *tree, void (*destr)(void*))$/;"	f
kd_free	kdtree.c	/^void kd_free(struct kdtree *tree)$/;"	f
kd_insert	kdtree.c	/^int kd_insert(struct kdtree *tree, const double *pos, void *data)$/;"	f
kd_insert3	kdtree.c	/^int kd_insert3(struct kdtree *tree, double x, double y, double z, void *data)$/;"	f
kd_insert3f	kdtree.c	/^int kd_insert3f(struct kdtree *tree, float x, float y, float z, void *data)$/;"	f
kd_insertf	kdtree.c	/^int kd_insertf(struct kdtree *tree, const float *pos, void *data)$/;"	f
kd_nearest	kdtree.c	/^struct kdres *kd_nearest(struct kdtree *kd, const double *pos)$/;"	f
kd_nearest3	kdtree.c	/^struct kdres *kd_nearest3(struct kdtree *tree, double x, double y, double z)$/;"	f
kd_nearest3f	kdtree.c	/^struct kdres *kd_nearest3f(struct kdtree *tree, float x, float y, float z)$/;"	f
kd_nearest_i	kdtree.c	/^static void kd_nearest_i(struct kdnode *node, const double *pos, struct kdnode **result, double *result_dist_sq, struct kdhyperrect* rect)$/;"	f	file:
kd_nearest_range	kdtree.c	/^struct kdres *kd_nearest_range(struct kdtree *kd, const double *pos, double range)$/;"	f
kd_nearest_range3	kdtree.c	/^struct kdres *kd_nearest_range3(struct kdtree *tree, double x, double y, double z, double range)$/;"	f
kd_nearest_range3f	kdtree.c	/^struct kdres *kd_nearest_range3f(struct kdtree *tree, float x, float y, float z, float range)$/;"	f
kd_nearest_rangef	kdtree.c	/^struct kdres *kd_nearest_rangef(struct kdtree *kd, const float *pos, float range)$/;"	f
kd_nearestf	kdtree.c	/^struct kdres *kd_nearestf(struct kdtree *tree, const float *pos)$/;"	f
kd_res_end	kdtree.c	/^int kd_res_end(struct kdres *rset)$/;"	f
kd_res_free	kdtree.c	/^void kd_res_free(struct kdres *rset)$/;"	f
kd_res_item	kdtree.c	/^void *kd_res_item(struct kdres *rset, double *pos)$/;"	f
kd_res_item3	kdtree.c	/^void *kd_res_item3(struct kdres *rset, double *x, double *y, double *z)$/;"	f
kd_res_item3f	kdtree.c	/^void *kd_res_item3f(struct kdres *rset, float *x, float *y, float *z)$/;"	f
kd_res_item_data	kdtree.c	/^void *kd_res_item_data(struct kdres *set)$/;"	f
kd_res_itemf	kdtree.c	/^void *kd_res_itemf(struct kdres *rset, float *pos)$/;"	f
kd_res_next	kdtree.c	/^int kd_res_next(struct kdres *rset)$/;"	f
kd_res_rewind	kdtree.c	/^void kd_res_rewind(struct kdres *rset)$/;"	f
kd_res_size	kdtree.c	/^int kd_res_size(struct kdres *set)$/;"	f
kdhyperrect	kdtree.c	/^struct kdhyperrect {$/;"	s	file:
kdnode	kdtree.c	/^struct kdnode {$/;"	s	file:
kdres	kdtree.c	/^struct kdres {$/;"	s	file:
kdres	rrt.h	/^typedef struct kdres kdres;$/;"	t	typeref:struct:kdres
kdtree	kdtree.c	/^struct kdtree {$/;"	s	file:
kdtree	rrt.h	/^typedef struct kdtree kdtree;$/;"	t	typeref:struct:kdtree
left	kdtree.c	/^    struct kdnode *left, *right;	\/* negative\/positive side *\/$/;"	m	struct:kdnode	typeref:struct:kdnode::kdnode	file:
main	genobs.c	/^int main(int argc, char *argv[])$/;"	f
main	main.cpp	/^int main(int argc, char* argv[])$/;"	f
max	kdtree.c	/^    double *min, *max;              \/* minimum\/maximum coords *\/$/;"	m	struct:kdhyperrect	file:
min	kdtree.c	/^    double *min, *max;              \/* minimum\/maximum coords *\/$/;"	m	struct:kdhyperrect	file:
nearest	rrt.cpp	/^Node* nearest(State s)$/;"	f
nearest_kdtree	rrt.cpp	/^Node* nearest_kdtree(kdtree *node_tree, State s)$/;"	f
next	kdtree.c	/^    struct res_node *next;$/;"	m	struct:res_node	typeref:struct:res_node::res_node	file:
obs_rad	rrt.cpp	/^double obs_rad[100];$/;"	v
obstree	rrt.cpp	/^kdtree *obstree;$/;"	v
operator !=	rrt.h	/^        bool operator!=(State s)$/;"	f	class:State
operator ==	rrt.h	/^        bool operator==(State s)$/;"	f	class:State
optpath	rrt.cpp	/^list<Node> optpath;     \/\/ stores softened path$/;"	v
parent	rrt.h	/^        Node *parent;$/;"	m	class:Node
path	rrt.cpp	/^list<Node> path;        \/\/ stores path that reaches goal$/;"	v
pos	kdtree.c	/^    double *pos;$/;"	m	struct:kdnode	file:
print	rrt.h	/^        void print()$/;"	f	class:State
print_path	main.cpp	/^void print_path(list<Node> whichpath)$/;"	f
process_tree_rrt	rrt.cpp	/^void process_tree_rrt(Node goal_node)$/;"	f
process_tree_rrtstar	rrt.cpp	/^void process_tree_rrtstar(Node *goal_node)$/;"	f
randdouble	random.cpp	/^double randdouble(double min, double max)$/;"	f
randfloat	random.cpp	/^float randfloat(float min, float max)$/;"	f
rd	genobs.c	/^double rd()$/;"	f
rdlim	genobs.c	/^double rdlim(double min, double max)$/;"	f
read_input	main.cpp	/^void read_input(char obs_file[])$/;"	f
rect	kdtree.c	/^    struct kdhyperrect *rect;$/;"	m	struct:kdtree	typeref:struct:kdtree::kdhyperrect	file:
res_node	kdtree.c	/^struct res_node {$/;"	s	file:
right	kdtree.c	/^    struct kdnode *left, *right;	\/* negative\/positive side *\/$/;"	m	struct:kdnode	typeref:struct:kdnode::	file:
riter	kdtree.c	/^    struct res_node *rlist, *riter;$/;"	m	struct:kdres	typeref:struct:kdres::	file:
rlist	kdtree.c	/^    struct res_node *rlist, *riter;$/;"	m	struct:kdres	typeref:struct:kdres::res_node	file:
rlist_insert	kdtree.c	/^static int rlist_insert(struct res_node *list, struct kdnode *item, double dist_sq)$/;"	f	file:
robot	rrt.cpp	/^State robot;$/;"	v
robot_radius	rrt.cpp	/^double robot_radius;$/;"	v
root	kdtree.c	/^    struct kdnode *root;$/;"	m	struct:kdtree	typeref:struct:kdtree::kdnode	file:
rrt_plan	rrt.cpp	/^double rrt_plan(double old_cost)$/;"	f
rrtstar_plan	rrt.cpp	/^double rrtstar_plan(int num_iter)$/;"	f
sample_state	rrt.cpp	/^State sample_state()$/;"	f
size	kdtree.c	/^    int size;$/;"	m	struct:kdres	file:
size	rrt.h	/^    double size;$/;"	m	struct:Goal
size	rrt.h	/^    double size[NUM_STATES];$/;"	m	struct:Box
state	rrt.h	/^        State state;$/;"	m	class:Node
state	rrt.h	/^    State state;$/;"	m	struct:Goal
tree	kdtree.c	/^    struct kdtree *tree;$/;"	m	struct:kdres	typeref:struct:kdres::kdtree	file:
tree	rrt.cpp	/^list<Node> tree;        \/\/ stores the tree$/;"	v
x	rrt.h	/^        double x[NUM_STATES];$/;"	m	class:State
